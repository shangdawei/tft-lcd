/*
**  ******************************************************************************************
**                                      ALARM
**         (c) Copyright 2009-2010, XXXX CO.LTD.
**                                    All Rights Reserved
**  ==========================================================================================
**	File		: decode.c
**  ==========================================================================================
**	Description	: Application enter pointer
**  ==========================================================================================
**  History     : Modify by  ||    ID    ||     Date      ||     Contents
**              :   xul      ||          ||   2009/09/14  || Create this file
**  ******************************************************************************************
*/

#define	_DEC_C_
//#include <ina90.h> 
#include "def.h"
#include "main.h"
#include "led.h"
#include "time.h"
#include "phone.h"

#define	BUFANG_CMD		0x01	//布防
#define	CHEFANG_CMD		0x02	//撤防
#define	ITC_CMD			0x03	//紧急报警
#define	PART_CF_CMD		0x04	//部分布撤防区撤防

/*------------------------------------------*/
#define	REMOTE_ADDR		0xAAAA

static bool Delay_flag = 0;

uint8   RecData[24]={0};//原始数据
uint8   Data[12]={0};//解码后存放的数据，前8字节为地址码，后4字节为数据码
                        //0，1，2分别表示0码，1码，悬空码
bool      count=0;//捕获中断次数奇偶判断,0为偶数,布尔数据类型

uint8   CodeCount=0;//接收原始码计数（24个字节）
uint8   StartCdoe=0;//间隔码标志位
uint8   CNT=0;//捕获值缓冲单元（取高8位）
uint8   flag=0;//接收原始码完成标志位

void decode_init(void)
{
  __disable_interrupt();
  PORTB |= (1 << PB0); 
  DDRB &= ~(1 << DDB0);//捕获端口设置为输入
  TIMSK1|=0x20; //输入捕获使能
  TCCR1B=0x42;   //上升沿捕获，时钟8分频1us计数一次,最大计数65ms 
  __enable_interrupt();
}
//**************************************
//定时器1输入捕获中断，上升沿触发
//
//
//*************************************
#pragma vector = TIMER1_CAPT_vect
__interrupt void timer1_capt_isr(void)
{
  uint8   CNT1=0;
  CNT1=ICR1L; 
  CNT=ICR1H; 
  count=!count;//奇偶标志互换
  if(count)//奇数次测低电平
  {
    TCCR1B&=~(1<<ICES1);//奇数次中断后置为下降沿触发，用于测高电平时间
    CNT1=CNT;
    CNT1=CNT1>>4;//只判断高8位的高4位是否大于0x03 
    if(CNT1>0x03)
    {
      StartCdoe=1;//间隔码标志置1
    }
  }
  else//偶数次测高电平时间
  {
    TCCR1B|=(1<<ICES1);//偶数次中断后置为上升沿触发，用于测高电平时间
    if(StartCdoe) //遇到间隔码则读取后面的24个码，取高8位的计算值
    {
      RecData[CodeCount++]=CNT;//读取地址码和数据码
      if(CodeCount==24)
      {
        CodeCount=0;//源码个数计数清零
        StartCdoe=0;//接收完原始码后，间隔码标志清零
        flag=1;//完成标志
      }
    }
  }
  TCNT1H=0;//定时器清零 
  TCNT1L=0;
}
//*********************************
//函数名称：void DecodeNew(void)
//函数功能：解码
//传递参数：无
//返回值：  无
//*********************************
void DecodeNew(void)
{
  uint8 DecodeCom=12,i=0,j=0;
  while(DecodeCom)
  {
    if((RecData[i]<3)&&(RecData[i+1]>3))//为悬空码
    {
      Data[j++]=2;
      i+=2;
    }
    else
    {
      if((RecData[i]<3)&&(RecData[i+1]<3))//都小于则为0码
      {
        Data[j++]=0;
        i+=2;
      }
      else//否则为1码
      {
        Data[j++]=1;
        i+=2;
      }
    }
    DecodeCom--;
  }
}
void alarm_delay_set(uint8 delay_s, int t)
{
	static uint8 i = 0;

	if(Delay_flag == 0)
	{
		i = 0;
		return ;
	}
	
	if(flag_1000ms == 1)
	{
		flag_1000ms = 0;
		i++;
	}
	if(i == delay_s)
	{
		Delay_flag = 0;
		gSysinfo.alarm_md = t;
	}
	
}
/*  $Function   :   alarm_set
==  ==============================================================================================
==  Description :   报警状态设置
==  ==============================================================================================
==  Argument    :   
==  ==============================================================================================
==  Return      :   
==              :   
==  ===============================================================================================
==  History     : Modify by  ||    ID    ||     Date      ||     Contents
==              :   xul      ||          ||   2009/10/12  || Create this function
==  ===============================================================================================
*/
void alarm_set(int	t)
{
	static int flag = 0;

	if(t == ALARM_OFF)
	{
		flag = 0;
		gSysinfo.alarm_md = ALARM_OFF;
	}
	else
	{
		if(flag == 0)
		{//表明是第一次按布防键，调用延时布防
			flag ++;
			Delay_flag = 1;
		}
		else
		{//第二次按布防键，立即布防
			gSysinfo.alarm_md = ALARM_ON;
		}
	}
}
/*  $Function   :   do_remote_cmd
==  ==============================================================================================
==  Description :   处理遥控器命令
==  ==============================================================================================
==  Argument    :   
==  ==============================================================================================
==  Return      :   
==              :   
==  ===============================================================================================
==  History     : Modify by  ||    ID    ||     Date      ||     Contents
==              :   xul      ||          ||   2009/09/26  || Create this function
==  ===============================================================================================
*/
void do_remote_cmd(uint8 val)
{
	switch(val)
	{
		case BUFANG_CMD://布防命令
			alarm_set(ALARM_ON);
			show_digled('S','F');
			break;
		case CHEFANG_CMD://撤防命令
			alarm_set(ALARM_OFF);
			show_digled('C','F');
			break;
		case ITC_CMD://紧急报警
			
			show_digled('9','9');
			break;
		case PART_CF_CMD://部分布撤防区撤防
			
			show_digled('b','F');
			break;
		default:
			break;
	}
}
/*  $Function   :   do_der_info
==  ==============================================================================================
==  Description :   处理探测器报警信号
==  ==============================================================================================
==  Argument    :   
==  ==============================================================================================
==  Return      :   
==              :   
==  ===============================================================================================
==  History     : Modify by  ||    ID    ||     Date      ||     Contents
==              :   xul      ||          ||   2009/10/9   || Create this function
==  ===============================================================================================
*/
void do_der_info(uint8 id)
{
	STWORK* pInfo = &gSysinfo;

	if(pInfo->alarm_md == ALARM_OFF)//属于撤防状态
		return;
	//============布防状态==========================//
	//电话报警、报警输出
	//
	if(pInfo->istel_set == 1)
	{//电话号码设置
		if(pInfo->istel_set == TEL_IS_SET)
		//拨电话号码
		{
			if(call_the_phone(pInfo) == 1)
			{//if(拨出成功) 播放语音，报警音输出，显示报警区号
				alarm_output(ALARM_ON);
			}
		}
		
	}
	else
	{//没有设置，直接声音报警
		alarm_output(ALARM_ON);
	}
}
/*  $Function   :   usr_pow
==  ==============================================================================================
==  Description :   简单的方次计算
==  ==============================================================================================
==  Argument    :   
==  ==============================================================================================
==  Return      :   
==              :   
==  ===============================================================================================
==  History     : Modify by  ||    ID    ||     Date      ||     Contents
==              :   xul      ||          ||   2009/10/9   || Create this function
==  ===============================================================================================
*/
int usr_pow(int m, int n)
{
	if(n < 0)
		return -1;

	while(--n)
	{
		m = m * m;
	}
	
	return m;
}
/*  $Function   :   covert_3rdnum
==  ==============================================================================================
==  Description :   把3进制数转换成10进制数
==  ==============================================================================================
==  Argument    :   
==  ==============================================================================================
==  Return      :   
==              :   
==  ===============================================================================================
==  History     : Modify by  ||    ID    ||     Date      ||     Contents
==              :   xul      ||          ||   2009/10/9   || Create this function
==  ===============================================================================================
*/
uint16 covert_3rdnum(uint8* src, uint8 num)
{
	uint8 i;
	uint16 val = 0;
	for(i = 0; i < num; i++)
	{
		val += (src[i] * usr_pow(3, num - i - 1));
	}

	return val;
}


/*  $Function   :   decode_process
==  ==============================================================================================
==  Description :   解码进程
==  ==============================================================================================
==  Argument    :   
==  ==============================================================================================
==  Return      :   
==              :   
==  ===============================================================================================
==  History     : Modify by  ||    ID    ||     Date      ||     Contents
==              :   xul      ||          ||   2009/09/26  || Create this function
==  ===============================================================================================
*/
void decode_process(void)
{
	uint16 data_addr = 0;
	uint8 data_buf = 0;
	STWORK* pInfo = &gSysinfo;
//	uint8 i;
	if(flag == 1)
	{
		flag = 0;
		DecodeNew();//解码
		/*
		for(i = 0; i < 8; i++)
			data_addr |= Data[i] << (14 - i*2);
		for(i = 8; i < 12; i++)
			data_buf |= Data[i] << (11 - i);
		*/
		data_addr = covert_3rdnum(Data, 8);
		data_buf = covert_3rdnum(&Data[8], 4);
		
		if(data_addr == REMOTE_ADDR)//遥控器地址，8位全部悬空
		{
			do_remote_cmd(data_buf);
		}
		else if(data_addr == pInfo->localID)//和本机ID相符
		{
			do_der_info(data_buf - 7);//参数代表防区号   减7的目的是为了和说明书的地址编码对照表一致
		}
	}
	alarm_delay_set(gSysinfo.al_del_tm, ALARM_ON);//检测延时报警
}

/*=============================================================================
==============================END OF THE FILE==================================
==============================================================================*/
